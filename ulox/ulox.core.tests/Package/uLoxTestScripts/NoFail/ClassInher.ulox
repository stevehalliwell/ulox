class Base 
{
    BaseMeth(){return 1;}
    Meth(){return this.BaseMeth();}
}

class Child < Base
{
    ChildMeth(){return 2;}
    Meth(){return this.ChildMeth();}

    ManualCombine(){return this.ChildMeth() + this.BaseMeth();}
    MethCombine(){return this.Meth() + super.Meth();}
    BoundSuper(){return super.Meth;}
}

test InherTests
{
    testcase CombineBaseAndChild
    {
        var expected = 3;
        var result = 0;
        var c = Child();

        result = c.BaseMeth() + c.ChildMeth();

        Assert.AreEqual(expected, result);
    }

    testcase MethHitsChildOnly
    {
        var expected = 4;
        var result = 0;
        var c = Child();

        result = c.Meth() + c.Meth();

        Assert.AreEqual(expected, result);
    }

    testcase MethodCombineBaseAndChild
    {
        var expected = 3;
        var result = 0;
        var c = Child();

        result = c.ManualCombine();

        Assert.AreEqual(expected, result);
    }

    testcase InnerMethWithSuper
    {
        var expected = 3;
        var result = 0;
        var c = Child();

        result = c.MethCombine();

        Assert.AreEqual(expected, result);
    }

    testcase MethodCombineBaseAndChildBound
    {
        var expected = 3;
        var result = 0;
        var c = Child();
        var m = c.ManualCombine;

        result = m();

        Assert.AreEqual(expected, result);
    }

    testcase InnerMethWithSuperBound
    {
        var expected = 4;
        var result = 0;
        var c = Child();
        var m = c.MethCombine;
        var bs = c.BoundSuper();

        result = m() + bs();

        Assert.AreEqual(expected, result);
    }
}